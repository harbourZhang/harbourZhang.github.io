{"meta":{"title":"Harbour个人博客","subtitle":"热爱生活，享受编程","description":"计算机技术小硕一枚","author":"Harbour","url":"https://harbourzhang99.github.io","root":"/"},"pages":[],"posts":[{"title":"Leetcode  0003","slug":"Leetcode0003","date":"2020-11-09T13:26:48.133Z","updated":"2020-11-09T13:37:38.373Z","comments":true,"path":"2020/11/09/Leetcode0003/","link":"","permalink":"https://harbourzhang99.github.io/2020/11/09/Leetcode0003/","excerpt":"收获：对于滑动窗口思考。","text":"收获：对于滑动窗口思考。 这道题一拿过来，倒是想到了用滑动窗口做。做的过程中出现了这么个问题： （1）如果最后一个字符没有重复，那么整体长度正常 （2）如果最后一个字符重复了，那么整体长度会增加1 是因为，最后一个字符如果重复了，那么最后一个字符的下标就用上了，而start位置的下标是那个重复字符的下标，于是这个重复字符就计算了两次。 然后瞄了一眼别人的答案，发现我的思路还是有很多的问题： （1）不论当前字符是否重复，当前字符都应当加入hashmap中。 （2）就算当前字符重复了，也不需要将之前存入hashmap的字符删除。因为把当前字符存入hashmap的时候，它会自动覆盖之前存储的键值对。 （3）当修改滑动窗口的左边位置时，应该想到，左边的窗口位置始终是一直变大的。而不是让左边的窗口位置回到上一个重复节点的位置。比如“abba”，第一次重复时，让左边窗口位置定位到b，而第二次重复时，如果把窗口左边位置定位回a，就会造成结果的错误。 我的答案：public static int lengthOfLongestSubstring(String s) &amp;#123; int start = 0; int end = 0; int len = 0; char[] chars = s.toCharArray(); HashMap&lt;Character, Integer> map = new HashMap&lt;>(); while ( end &lt; chars.length ) &amp;#123; if (map.containsKey(chars[end])) &amp;#123; start = Math.max(map.get(chars[end]) + 1,start); // start = map.get(chars[end]) + 1; &amp;#125; map.put(chars[end], end); len = Math.max(end - start + 1, len); end++; &amp;#125; return len; &amp;#125; 官方答案：class Solution &amp;#123; public int lengthOfLongestSubstring(String s) &amp;#123; // 哈希集合，记录每个字符是否出现过 Set&lt;Character> occ = new HashSet&lt;Character>(); int n = s.length(); // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动 int rk = -1, ans = 0; for (int i = 0; i &lt; n; ++i) &amp;#123; if (i != 0) &amp;#123; // 左指针向右移动一格，移除一个字符 occ.remove(s.charAt(i - 1)); &amp;#125; while (rk + 1 &lt; n &amp;&amp; !occ.contains(s.charAt(rk + 1))) &amp;#123; // 不断地移动右指针 occ.add(s.charAt(rk + 1)); ++rk; &amp;#125; // 第 i 到 rk 个字符是一个极长的无重复字符子串 ans = Math.max(ans, rk - i + 1); &amp;#125; return ans; &amp;#125; &amp;#125; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://harbourzhang99.github.io/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"https://harbourzhang99.github.io/tags/leetcode/"}]},{"title":"Leetcode  0001","slug":"Leetcode0001","date":"2020-11-09T02:44:44.537Z","updated":"2020-11-09T05:29:14.028Z","comments":true,"path":"2020/11/09/Leetcode0001/","link":"","permalink":"https://harbourzhang99.github.io/2020/11/09/Leetcode0001/","excerpt":"收获：对于去重，查找唯一的思考。","text":"收获：对于去重，查找唯一的思考。 由于当天没有准时写笔记，导致思路有些模糊。 （1）寻找匹配的两个数，如果用两层for循环，时间复杂度会非常高。而hashmap有个containsKey方法，很高效。并且hashmap还有去重的效果。 我的答案：class Solution &amp;#123; public int[] twoSum(int[] nums, int target) &amp;#123; HashMap&lt;Integer, Integer> hashmap = new HashMap&lt;>(); for(int i=0;i&lt;nums.length;i++)&amp;#123; if (hashmap.containsKey(target - nums[i]))&amp;#123; return new int []&amp;#123; hashmap.get(target - nums[i]),i&amp;#125;; &amp;#125;else&amp;#123; hashmap.put(nums[i],i); &amp;#125; &amp;#125; return new int[] &amp;#123;&amp;#125;; &amp;#125; &amp;#125; 官方答案：class Solution &amp;#123; public int[] twoSum(int[] nums, int target) &amp;#123; Map&lt;Integer, Integer> hashtable = new HashMap&lt;Integer, Integer>(); for (int i = 0; i &lt; nums.length; ++i) &amp;#123; if (hashtable.containsKey(target - nums[i])) &amp;#123; return new int[]&amp;#123;hashtable.get(target - nums[i]), i&amp;#125;; &amp;#125; hashtable.put(nums[i], i); &amp;#125; return new int[0]; &amp;#125; &amp;#125; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://harbourzhang99.github.io/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"https://harbourzhang99.github.io/tags/leetcode/"}]},{"title":"Leetcode  0002","slug":"Leetcode0002","date":"2020-11-09T02:16:38.131Z","updated":"2020-11-09T02:44:39.549Z","comments":true,"path":"2020/11/09/Leetcode0002/","link":"","permalink":"https://harbourzhang99.github.io/2020/11/09/Leetcode0002/","excerpt":"收获：对于链表的节点，游标的思考。","text":"收获：对于链表的节点，游标的思考。 （1）当需要构造一个链表的时候，可以用一个游标cursor指向根节点。 （2）取到一个新结点的值以后，将该值赋予cursor-&gt;next。如下代码，由于构造方法里有这样一个构造器，所以会自动构造一个节点，连接上cursor的next。 ListNode(int val) &amp;#123; this.val = val; &amp;#125; （3）将cursor指向其next。cursor原本引用的是root的地址值，现在让其指向next，就相当于让cursor引用root的next的地址值，也即步骤（2）中新结点的地址值。这样做，可以让我们的链表继续向后添加，并且也不会对原有链表的节点造成破坏。 （4）在步骤（2）里，是不能让cursor直接变成新结点的。否则步骤（3）中，cursor的next是空节点，而cursor又指向其next，这时等于清空了root值，导致链表一直进行“ cursor变为新结点-&gt; cursor指向next -&gt; cursor变为空 -&gt; cursor变为新结点…. ”的死循环。 我的答案：/** * Definition for singly-linked list. * public class ListNode &amp;#123; * int val; * ListNode next; * ListNode() &amp;#123;&amp;#125; * ListNode(int val) &amp;#123; this.val = val; &amp;#125; * ListNode(int val, ListNode next) &amp;#123; this.val = val; this.next = next; &amp;#125; * &amp;#125; */ class Solution &amp;#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &amp;#123; ListNode root = new ListNode(0); ListNode cursor = root; int more = 0; int val = 0; while ( l1 != null || l2 != null || more != 0) &amp;#123; if (l1 == null &amp;&amp; l2 == null) &amp;#123; val = more; more = 0; &amp;#125;else if (l1 == null) &amp;#123; // val是当前位应该存放的数字，more是进一位的值 val = (l2.val + more) % 10; more = (l2.val + more) / 10; &amp;#125;else if (l2 == null) &amp;#123; // val是当前位应该存放的数字，more是进一位的值 val = (l1.val + more) % 10; more = (l1.val + more) / 10; &amp;#125;else&amp;#123; // val是当前位应该存放的数字，more是进一位的值 val = (l1.val + l2.val + more) % 10; more = (l1.val + l2.val + more) / 10; &amp;#125; cursor.next = new ListNode(val); cursor = cursor.next; if (l1 != null) &amp;#123; l1 = l1.next; &amp;#125; if (l2 != null) &amp;#123; l2 = l2.next; &amp;#125; &amp;#125; return root.next; &amp;#125; &amp;#125; 官方答案：class Solution &amp;#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &amp;#123; ListNode head = null, tail = null; int carry = 0; while (l1 != null || l2 != null) &amp;#123; int n1 = l1 != null ? l1.val : 0; int n2 = l2 != null ? l2.val : 0; int sum = n1 + n2 + carry; if (head == null) &amp;#123; head = tail = new ListNode(sum % 10); &amp;#125; else &amp;#123; tail.next = new ListNode(sum % 10); tail = tail.next; &amp;#125; carry = sum / 10; if (l1 != null) &amp;#123; l1 = l1.next; &amp;#125; if (l2 != null) &amp;#123; l2 = l2.next; &amp;#125; &amp;#125; if (carry > 0) &amp;#123; tail.next = new ListNode(carry); &amp;#125; return head; &amp;#125; &amp;#125; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/add-two-numbers/solution/liang-shu-xiang-jia-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://harbourzhang99.github.io/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"https://harbourzhang99.github.io/tags/leetcode/"}]},{"title":"spring cloud 云服务分布式架构","slug":"GuliMall","date":"2020-11-07T12:01:51.000Z","updated":"2020-11-09T02:41:51.622Z","comments":true,"path":"2020/11/07/GuliMall/","link":"","permalink":"https://harbourzhang99.github.io/2020/11/07/GuliMall/","excerpt":"一些关于微服务，分布式架构的学习笔记","text":"一些关于微服务，分布式架构的学习笔记 一、Spring Could Nacos 【注册中心】1. 下载地址：https://github.com/alibaba/nacos/releases 2. 启动（1） bin目录下 点击startup.cmd（2）配置依赖&lt;dependency> &lt;groupId>com.alibaba.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId> &lt;version>2.2.1.RELEASE&lt;/version> &lt;/dependency> （3）配置application.yml文件spring: application: name: gulimall-member cloud: nacos: discovery: server-addr: 127.0.0.1:8848 （4）在主启动类上添加 @EnableDiscoveryClient 注解（5）启动主启动类。二、SpringCloud Feign微服务之间互相调用的一个声明式的Web Service客户端。当本服务想要调用外部服务时，使用feign来建立一个接口，本服务调用此接口，此接口再调用外部服务返回信息。 1. 使用步骤：（1）配置依赖&lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-openfeign&lt;/artifactId> &lt;/dependency> （2）告诉springcloud 使用Feign进行微服务之间的调用​ 创建 Feign 包，对应的微服务Service接口， 并添加@ FeignClient注解。 注意方法名最好一致 // 待调用服务的Controller @RequestMapping(\"coupon/coupon\") public class CouponController &amp;#123; @Autowired private CouponService couponService; @RequestMapping(\"/test\") public R couponToMember() &amp;#123; CouponEntity entity = new CouponEntity(); entity.setCouponName(\"测试使用-满100减50\"); return R.ok().put(\"coupon\",entity); &amp;#125; &amp;#125; // Feign接口 @FeignClient(\"gulimall-coupon\") // 如果要调用接口的这个方法，先从注册中心的这个微服务开始寻找 public interface CouponFeignService &amp;#123; @RequestMapping(\"/coupon/coupon/test\") public R couponToMember(); &amp;#125; // 本服务的Controller @Resource private CouponFeignService service; @RequestMapping(\"/test\") public R couponToMember() &amp;#123; R r = service.couponToMember(); return r; &amp;#125; （3）在主启动类上添加 @EnableFeignClient 注解@EnableFeignClients(basePackages = \"com.atguigu.gulimall.member.feign\") 三、Nacos 作为配置中心1. 使用步骤：（1） 配置依赖：&lt;dependency> &lt;groupId>com.alibaba.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-alibaba-nacos-config&lt;/artifactId> &lt;/dependency> （2） 创建配置文件 bootstrap.properties, 并添加以下配置spring.cloud.nacos.config.server-addr=127.0.0.1:8848 spring.application.name=gulimall-member （3） 在Nacos服务中心创建【服务名.properties】配置文件member.username=harbour member.info=测试文件 （4）编写相关业务逻辑（5）在对应的Controller上添加@RefreshScope的注解@RefreshScope 2. 环境隔离每个微服务创建自己的命名空间，使用配置分组区分环境，如dev，test，prod等 （1） 命名空间：默认public，用于在微服务之间进行配置隔离，每个微服务创建自己的命名空间，需要在bootstrap.properties加入以下配置： spring.cloud.nacos.config.namespace= 【Nacos中的命名空间ID】 （2） 配置集：所有配置的集合 （3） 配置集ID:Data-ID : 类似于配置文件名 （4）配置分组：需要在bootstrap.properties加入以下配置： spring.cloud.nacos.config.group= 【Nacos中的分组名】 3. 加载多配置文件在bootstrap.properties中，使用spring.cloud.nacos.config.ext-config配置配置文件。默认加载【文件名-properties】配置文件。 spring.cloud.nacos.config.ext-config[0].data-id=mybatis.yaml spring.cloud.nacos.config.ext-config[0].group=dev spring.cloud.nacos.config.ext-config[0].refresh=true spring.cloud.nacos.config.ext-config[1].data-id=datasource.yaml spring.cloud.nacos.config.ext-config[1].group=dev spring.cloud.nacos.config.ext-config[1].refresh=true spring.cloud.nacos.config.ext-config[2].data-id=cloud.yaml spring.cloud.nacos.config.ext-config[2].group=dev spring.cloud.nacos.config.ext-config[2].refresh=true 四、Spring Cloud Gateway1.使用步骤（1）导入依赖：&lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-gateway&lt;/artifactId> &lt;/dependency> （2）根据不同的需求，配置yamlspring: cloud: gateway: routes: - id: admin_route uri: lb://renren-fast predicates: - Path=/api/** filters: - RewritePath=/api/(?&lt;segment>.*),/renren-fast/$\\&amp;#123;segment&amp;#125; nacos: discovery: server-addr: 127.0.0.1:8848 application: name: gulimall-gateway server: port: 88 (3) 修改主启动类在主启动类上增加@EnableDiscoveyClient 注解 五、解决浏览器跨域解决方案：@Configuration public class MyCorsConfiguration &amp;#123; public CorsWebFilter getCorsWebFilter () &amp;#123; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); CorsConfiguration configuration = new CorsConfiguration(); configuration.addAllowedHeader(\"*\"); configuration.addAllowedMethod(\"*\"); configuration.addAllowedOrigin(\"*\"); configuration.setAllowCredentials(true); source.registerCorsConfiguration(\"/**\",configuration); return new CorsWebFilter(source); &amp;#125; &amp;#125; 六、整合MybatisPlus1.导入依赖&lt;dependency> &lt;groupId>com.baomidou&lt;/groupId> &lt;artifactId>mybatis-plus-boot-starter&lt;/artifactId> &lt;version>3.3.1&lt;/version> &lt;/dependency> &lt;!-- 数据源 --> &lt;dependency> &lt;groupId>com.alibaba&lt;/groupId> &lt;artifactId>druid&lt;/artifactId> &lt;version>1.1.13&lt;/version> &lt;/dependency> 2. 配置（1）配置数据源# 配置mybatisplus mybatis-plus: # MyBatis Mapper 所对应的 XML 文件位置 # Maven 多模块项目的扫描路径需以 classpath*: 开头 （即加载多个 jar 包下的 XML 文件） mapper-locations: classpath*:/mapper/**/*.xml # 设置主键自增 global-config: db-config: id-type: auto （2）使用@MapperScan注解使用@MapperScan注解告诉MybatisPlus的sql映射位置 3.逻辑删除（1）配置yaml (注：since 3.3.0,配置后可以忽略不配置步骤2)mybatis-plus: global-config: db-config: logic-delete-field: flag # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2) logic-delete-value: 1 # 逻辑已删除值(默认为 1) logic-not-delete-value: 0 # 逻辑未删除值(默认为 0) （2）实体类字段上加上@TableLogic注解@TableLogic private Integer deleted;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://harbourzhang99.github.io/tags/java/"},{"name":"spring cloud","slug":"spring-cloud","permalink":"https://harbourzhang99.github.io/tags/spring-cloud/"}]}],"categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://harbourzhang99.github.io/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"https://harbourzhang99.github.io/tags/leetcode/"},{"name":"java","slug":"java","permalink":"https://harbourzhang99.github.io/tags/java/"},{"name":"spring cloud","slug":"spring-cloud","permalink":"https://harbourzhang99.github.io/tags/spring-cloud/"}]}