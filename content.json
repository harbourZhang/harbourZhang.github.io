{"meta":{"title":"Harbour个人博客","subtitle":"热爱生活，享受编程","description":"计算机技术小硕一枚","author":"Harbour","url":"https://harbourzhang99.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-09-14T07:30:30.000Z","updated":"2020-11-09T14:31:57.133Z","comments":true,"path":"categories/index.html","permalink":"https://harbourzhang99.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-09-14T07:30:30.000Z","updated":"2020-11-09T14:48:06.167Z","comments":true,"path":"friends/index.html","permalink":"https://harbourzhang99.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-09-14T07:30:30.000Z","updated":"2020-11-09T14:32:58.425Z","comments":true,"path":"tags/index.html","permalink":"https://harbourzhang99.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2020-09-14T07:30:30.000Z","updated":"2020-11-10T00:29:28.551Z","comments":true,"path":"about/index.html","permalink":"https://harbourzhang99.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Leetcode  0005","slug":"Leetcode0005","date":"2020-11-13T00:53:16.273Z","updated":"2020-11-13T02:26:34.448Z","comments":true,"path":"2020/11/13/Leetcode0005/","link":"","permalink":"https://harbourzhang99.github.io/2020/11/13/Leetcode0005/","excerpt":"收获：多种方案与思想解决最大回文子串。","text":"收获：多种方案与思想解决最大回文子串。 我的答案：暴力解法，从第一个元素开始，逐次增加字符串的长度，并判断该字符串是否是回文，取出最大的结果。 // 暴力解法 // 最长的回文子串 public static String longestPalindrome(String s) &amp;#123; if (s.length() &lt;= 1) return s; int max = 1; int left = 0; // 暴力法，从第一个元素开始，逐次增加字符串的长度，并判断该字符串是否是回文，取出最大的结果。 for (int i = 0; i &lt; s.length()-1; i++) &amp;#123; for (int j = i+1; j &lt; s.length(); j++) &amp;#123; if (j-i+1 > max &amp;&amp; isPalindrome(s,i,j)) &amp;#123; max = j-i+1; left = i; &amp;#125; &amp;#125; &amp;#125; return s.substring(left,left+max); &amp;#125; // 判断是否是回文 public static boolean isPalindrome(String s, int left, int right) &amp;#123; if (s.length() &lt;= 1) return true; while ( left &lt; right) &amp;#123; if (s.charAt(left) != s.charAt(right)) &amp;#123; return false; &amp;#125; left++; right--; &amp;#125; return true; &amp;#125; 动态规划解法： P（i，j） 是回文的前提条件是 “子串（i+1，j-1）是回文字符串”，并且“P（i）== P（j）“ 边界条件是 字符串长度为0 或 1 的情况。 // 动态规划 public static String longestPalindrome2(String s) &amp;#123; int max = 0; int left = 0; int len = s.length(); boolean[][] dp = new boolean[len][len]; // 外围控制子串的长度 for(int l=0; l&lt;s.length(); l++) &amp;#123; //从i开始时，遍历直到i+l等于数组边界。 for (int i = 0; i &lt;s.length()-l; i++) &amp;#123; int j = i+l; if(l == 0) &amp;#123; dp[i][j] = true; &amp;#125;else if( l == 1)&amp;#123; dp[i][j] = s.charAt(i)==s.charAt(j); &amp;#125;else&amp;#123; dp[i][j] = s.charAt(i)==s.charAt(j) &amp;&amp; dp[i+1][j-1]; &amp;#125; // 若长度大于max，并且此子串为回文 if ( l > max &amp;&amp; dp[i][j] ) &amp;#123; left = i; max = l; &amp;#125; &amp;#125; &amp;#125; return s.substring(left,left+max+1); &amp;#125; 官方答案：// 中心扩展算法 // 以每个字符或每连续两个字符做中心，每次往左右各扩散一位。每次扩散时，判断左右扩散的元素是否相等。 // 如果想等，长度加2，如果不等返回该长度。 // 于是空间复杂度只有1。 class Solution &amp;#123; public String longestPalindrome(String s) &amp;#123; if (s == null || s.length() &lt; 1) &amp;#123; return \"\"; &amp;#125; int start = 0, end = 0; for (int i = 0; i &lt; s.length(); i++) &amp;#123; int len1 = expandAroundCenter(s, i, i); int len2 = expandAroundCenter(s, i, i + 1); int len = Math.max(len1, len2); if (len > end - start) &amp;#123; start = i - (len - 1) / 2; end = i + len / 2; &amp;#125; &amp;#125; return s.substring(start, end + 1); &amp;#125; public int expandAroundCenter(String s, int left, int right) &amp;#123; while (left >= 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &amp;#123; --left; ++right; &amp;#125; return right - left - 1; &amp;#125; &amp;#125; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://harbourzhang99.github.io/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"https://harbourzhang99.github.io/tags/leetcode/"},{"name":"回文","slug":"回文","permalink":"https://harbourzhang99.github.io/tags/%E5%9B%9E%E6%96%87/"},{"name":"动态规划","slug":"动态规划","permalink":"https://harbourzhang99.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"SSM - spring支持的常用数据库事务传播属性和事务隔离级别","slug":"SSM面试题[spring支持的常用数据库事务传播属性和事务隔离级别]","date":"2020-11-11T08:50:32.120Z","updated":"2020-11-11T09:06:09.204Z","comments":true,"path":"2020/11/11/SSM面试题[spring支持的常用数据库事务传播属性和事务隔离级别]/","link":"","permalink":"https://harbourzhang99.github.io/2020/11/11/SSM%E9%9D%A2%E8%AF%95%E9%A2%98[spring%E6%94%AF%E6%8C%81%E7%9A%84%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB]/","excerpt":"收获：ssm学习笔记。","text":"收获：ssm学习笔记。 spring支持的常用数据库事务传播属性和事务隔离级别事务是恢复和并发控制的基本单位。 事务应该具有4个属性：==原子性、一致性、隔离性、持久性==。这四个属性通常称为ACID特性。 属性 释义 原子性（atomicity） 一个事务是一个不可分割的工作单位，事务中包括的操作要么都做，要么都不做。 一致性（consistency） 事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。 隔离性（isolation） 一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性（durability） 持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。 1. Spring支持的常用数据库事务传播属性和事务隔离级别//请简单介绍Spring支持的常用数据库事务传播属性和事务隔离级别？ /** * 事务的属性： * 1.★propagation：用来设置事务的传播行为 * 事务的传播行为：一个方法运行在了一个开启了事务的方法中时，当前方法是使用原来的事务还是开启一个新的事务 * -Propagation.REQUIRED：默认值，使用原来的事务 * -Propagation.REQUIRES_NEW：将原来的事务挂起，开启一个新的事务 * 2.★isolation：用来设置事务的隔离级别 * -Isolation.REPEATABLE_READ：可重复读，MySQL默认的隔离级别 * -Isolation.READ_COMMITTED：读已提交，Oracle默认的隔离级别，开发时通常使用的隔离级别 */ 2. 事务的传播属性：当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继承在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。 事务的传播行为可以由传播属性指定。Spring定义了7种类型的传播行为。 传播属性 描述 REQUIRED （默认） 如果有事务在运行，当前的方法就在这个事务内运行，否则，就启动一个新的事务，并在自己的事务内运行 REQUIRES_NEW 当前的方法必须启动新的事务，并在它自己的事务内运行，如果有事务正在运行，应该将它挂起 SUPPORTS 如果有事务正在运行，当前的方法就在这个事务内运行。否则它可以不运行在事务中 NOT_SUPPORTED 当前的方法不应该运行在事务中。如果有运行的事务，将它挂起 MANDATORY 当前的方法必须运行在事务内部。如果没有正在运行的事务，就抛出异常 NEVER 当前的方法不应该运行在事务中。如果有运行的事务,就抛出异常 NESTED 如果有事务在运行，当前的方法就应该在这个事务的嵌套事务内运行。否则，就启动一个新的事务，并在它自己的事务内运行 3. 事务的隔离级别(1) 数据库事务并发问题假设现在有两个事务：Transaction01和Transaction02并发执行 ==脏读== Transaction01 将某条记录的AGE值从20修改为30 Transaction02 读取了 Transaction01 更新后的值：30 Transaction01 回滚，AGE值恢复到了20 Transaction02 读到的30就是一个无效的值 ==不可重复读== Transaction01读取了AGE值为20 Transaction02将AGE值修改为30 Transaction01再次读取AGE值为30，和第一次读取的不一致 ==幻读== Transaction01读取了stu表中的一部分数据 Transaction02向stu表中插入了新的行 Transaction01读取stu表时，多出了一些行 (2) 事务的隔离级别数据库系统必须具有隔离并发运行各个事务的能力，使他们不会相互影响，避免各种并发问题。一个事务与其他事务隔离的程度称为隔离级别。SQL标准中规定了好多事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，性能开销越大 ==读未提交：READ UNCOMMITTED==允许Transaction01读取Transaction02未提交的修改(上面三种情况都不可避免） ==读已提交：READ COMMITTED==（常用的，其他事务已经提交的数据都认为是真的） 要求Transaction01只能读取Transaction02已提交的修改（可避免脏读） ==可重复读：REPEATABLE READ==确保Transaction01可以多次从一个字段中读取到相同的值，即Transaction01执行期间禁止其他事务对这个字段进行更新。（可避免脏读，不可重复读） ==串行化：SERIALIZABLE==确保Transaction01可以从一个表中读取到相同的行，在Transaction01执行期间，禁止其他事务对这个表进行增删改操作。可以避免任何并发问题，但性能十分低下。 各个隔离级别解决并发问题的能力见下表 隔离级别 脏读 不可重复读 幻读 READ UNCOMMITTED 有 有 有 READ COMMITTED 无 有 有 REPEATABLE READ 无 无 有 SERIALIZABLE 无 无 无 各种数据库产品对事务隔离级别的支持程度 隔离级别 Oracle MySQL READ UNCOMMITTED x √ READ COMMITTED √(默认) √ REPEATABLE READ x √(默认) SERIALIZABLE √ √","categories":[],"tags":[{"name":"ssm","slug":"ssm","permalink":"https://harbourzhang99.github.io/tags/ssm/"},{"name":"数据库","slug":"数据库","permalink":"https://harbourzhang99.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"事务","slug":"事务","permalink":"https://harbourzhang99.github.io/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"面试题","slug":"面试题","permalink":"https://harbourzhang99.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"SSM - bean的作用域","slug":"SSM面试题[bean的作用域]","date":"2020-11-11T07:30:36.998Z","updated":"2020-11-11T09:06:15.644Z","comments":true,"path":"2020/11/11/SSM面试题[bean的作用域]/","link":"","permalink":"https://harbourzhang99.github.io/2020/11/11/SSM%E9%9D%A2%E8%AF%95%E9%A2%98[bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F]/","excerpt":"收获：ssm学习笔记。","text":"收获：ssm学习笔记。 1. bean的作用域&lt;!-- ★bean的作用域 可以通过scope属性来指定bean的作用域 -singleton：默认值。当IOC容器一创建就会创建bean的实例，而且是单例的，每次得到的都是同一个 -prototype：原型的。当IOC容器一创建不再实例化该bean，每次调用getBean方法时再实例化该bean，而且每调用一次创建一个对象 -request：每次请求实例化一个bean -session：在一次会话中共享一个bean --> &lt;bean id=\"book\" class=\"com.atguigu.spring.beans.Book\" scope=\"prototype\"> &lt;property name=\"id\" value=\"8\">&lt;/property> &lt;property name=\"title\" value=\"红高粱\">&lt;/property> &lt;property name=\"author\" value=\"莫言\">&lt;/property> &lt;property name=\"price\" value=\"10.00\">&lt;/property> &lt;property name=\"sales\" value=\"800\">&lt;/property> &lt;/bean>","categories":[],"tags":[{"name":"ssm","slug":"ssm","permalink":"https://harbourzhang99.github.io/tags/ssm/"},{"name":"面试题","slug":"面试题","permalink":"https://harbourzhang99.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"循环与递归","slug":"java面试题[循环与迭代]","date":"2020-11-11T06:51:24.790Z","updated":"2020-11-11T09:48:32.640Z","comments":true,"path":"2020/11/11/java面试题[循环与迭代]/","link":"","permalink":"https://harbourzhang99.github.io/2020/11/11/java%E9%9D%A2%E8%AF%95%E9%A2%98[%E5%BE%AA%E7%8E%AF%E4%B8%8E%E8%BF%AD%E4%BB%A3]/","excerpt":"收获：对于循环与递归的思考。","text":"收获：对于循环与递归的思考。 有N步台阶，每次走1步或2步，一共有多少种走法 ？1.递归方法调用自身称为递归 （1）优点：大问题转化为小问题，可以减少代码量，同时代码精简，可读性好； （2）缺点：递归调用浪费了空间，而且递归太深容易造成堆栈的溢出。 // 递归的方法 public static int step(int n) &amp;#123; if(n >= 2)&amp;#123; return step(n-1) + step(n -2); &amp;#125;else&amp;#123; return 1; &amp;#125; &amp;#125; 2.迭代（循环）利用变量的原值推出新值称为迭代 （1）优点：代码运行效率好，因为时间只因循环次数增加而增加，而且没有额外的空间开销； （2）缺点：代码不如递归简洁，可读性好 // 循环的方法 public static int step2(int n) &amp;#123; int[] mat = new int[n]; mat[0] = 1; mat[1] = 2; for (int i = 2; i &lt; n; i++) &amp;#123; mat[i] = mat[i-1] + mat[i-2]; &amp;#125; return mat[n-1]; &amp;#125;","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://harbourzhang99.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"javase","slug":"javase","permalink":"https://harbourzhang99.github.io/tags/javase/"}]},{"title":"java 参数的传递机制","slug":"java面试题[参数的传递机制]","date":"2020-11-11T05:43:19.142Z","updated":"2020-11-11T09:51:10.845Z","comments":true,"path":"2020/11/11/java面试题[参数的传递机制]/","link":"","permalink":"https://harbourzhang99.github.io/2020/11/11/java%E9%9D%A2%E8%AF%95%E9%A2%98[%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6]/","excerpt":"收获：对于java参数传递机制的思考。","text":"收获：对于java参数传递机制的思考。 运行结果： 方法的参数传递机制1. 基本数据类型（1）传递数据值 2. 引用数据类型（1）传递地址值 （2）String、包装类等对象的不可变性 内存结构1. 基本数据类型（1）基本数据类型，直接存储在栈中。 2. 引用数据类型（1）引用数据类型，其地址值存储在栈中，实际上真正的数据存储在堆中，或常量池内 （2）栈中的地址值指向堆中的数据。实参传递给形参时，形参实际上拿到的是一个地址值。当对这个地址值指向的数据进行修改的时候，连带就会影响原本的实参。 （3）String类型变量比较特殊，当其进行修改时，是重新在常量池中创建一个修改后的数据，然后把新数据的地址值传递给形参。也就是说，原本的实参还是指向修改前的数据。形参则指向了修改后的数据。 ==建议以后复习画一下内存结构图==","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://harbourzhang99.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"javase","slug":"javase","permalink":"https://harbourzhang99.github.io/tags/javase/"}]},{"title":"Leetcode  0006","slug":"Leetcode0006","date":"2020-11-11T02:16:31.407Z","updated":"2020-11-11T02:41:47.758Z","comments":true,"path":"2020/11/11/Leetcode0006/","link":"","permalink":"https://harbourzhang99.github.io/2020/11/11/Leetcode0006/","excerpt":"Z 字形变换","text":"Z 字形变换 虽然做出来了，但是时间复杂度，空间复杂度都较差 我的答案：public static String convert(String s, int numRows) &amp;#123; if (numRows == 1) &amp;#123; return s; &amp;#125; // true 代表向下， false代表向右上 boolean direction = true; char[][] mat = new char[numRows][s.length()]; String res = \"\"; int index = 0; int round = 1; int row = 0; int col = 0; while(index &lt; s.length())&amp;#123; mat[row][col] = s.charAt(index); index++; round++; if (direction) &amp;#123; row++; &amp;#125; else &amp;#123; row--; col++; &amp;#125; if (round%numRows == 0) &amp;#123; direction = !direction; round = 1; &amp;#125; &amp;#125; for (int i=0;i&lt;numRows;i++) &amp;#123; for(int j=0;j&lt;s.length();j++)&amp;#123; if (mat[i][j] != '\\u0000') &amp;#123; String temp = Character.toString(mat[i][j]); res = res.concat(temp); &amp;#125; &amp;#125; &amp;#125; return res; &amp;#125; 官方答案：class Solution &amp;#123; public String convert(String s, int numRows) &amp;#123; if (numRows == 1) return s; List&lt;StringBuilder> rows = new ArrayList&lt;>(); for (int i = 0; i &lt; Math.min(numRows, s.length()); i++) rows.add(new StringBuilder()); int curRow = 0; boolean goingDown = false; for (char c : s.toCharArray()) &amp;#123; rows.get(curRow).append(c); if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown; curRow += goingDown ? 1 : -1; &amp;#125; StringBuilder ret = new StringBuilder(); for (StringBuilder row : rows) ret.append(row); return ret.toString(); &amp;#125; &amp;#125; 作者：LeetCode 链接：https://leetcode-cn.com/problems/zigzag-conversion/solution/z-zi-xing-bian-huan-by-leetcode/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://harbourzhang99.github.io/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"https://harbourzhang99.github.io/tags/leetcode/"}]},{"title":"Leetcode  0004","slug":"Leetcode0004","date":"2020-11-10T13:28:16.816Z","updated":"2020-11-10T13:40:39.448Z","comments":true,"path":"2020/11/10/Leetcode0004/","link":"","permalink":"https://harbourzhang99.github.io/2020/11/10/Leetcode0004/","excerpt":"收获：如果对时间复杂度的要求有 log，通常都需要用到二分查找。","text":"收获：如果对时间复杂度的要求有 log，通常都需要用到二分查找。 这个问题，实际上可以解析为，两个有序数组，找到第K大的元素。 我的答案：public static double findMedianSortedArrays(int[] nums1, int[] nums2) &amp;#123; int len = nums1.length + nums2.length; if (len == 0) &amp;#123; return 0.0; &amp;#125; int[] arr = new int[len]; int cursor1 = 0; int cursor2 = 0; int index = 0; while( index &lt; len) &amp;#123; if ( cursor1 == nums1.length) &amp;#123; while (cursor2 &lt; nums2.length) &amp;#123; arr[index++] = nums2[cursor2++]; &amp;#125; &amp;#125; else if ( cursor2 == nums2.length) &amp;#123; while (cursor1 &lt; nums1.length) &amp;#123; arr[index++] = nums1[cursor1++]; &amp;#125; &amp;#125; else &amp;#123; if (nums1[cursor1] &lt; nums2[cursor2]) &amp;#123; arr[index++] = nums1[cursor1]; cursor1++; &amp;#125;else if (nums1[cursor1] >= nums2[cursor2]) &amp;#123; arr[index++] = nums2[cursor2]; cursor2++; &amp;#125; &amp;#125; &amp;#125; return len%2==0 ? (arr[len/2]+arr[len/2-1])/2.0 : arr[len/2]/1.0; &amp;#125; 官方答案：class Solution &amp;#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &amp;#123; int length1 = nums1.length, length2 = nums2.length; int totalLength = length1 + length2; if (totalLength % 2 == 1) &amp;#123; int midIndex = totalLength / 2; double median = getKthElement(nums1, nums2, midIndex + 1); return median; &amp;#125; else &amp;#123; int midIndex1 = totalLength / 2 - 1, midIndex2 = totalLength / 2; double median = (getKthElement(nums1, nums2, midIndex1 + 1) + getKthElement(nums1, nums2, midIndex2 + 1)) / 2.0; return median; &amp;#125; &amp;#125; public int getKthElement(int[] nums1, int[] nums2, int k) &amp;#123; /* 主要思路：要找到第 k (k>1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较 * 这里的 \"/\" 表示整除 * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个 * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个 * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个 * 这样 pivot 本身最大也只能是第 k-1 小的元素 * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 \"删除\"，剩下的作为新的 nums1 数组 * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 \"删除\"，剩下的作为新的 nums2 数组 * 由于我们 \"删除\" 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数 */ int length1 = nums1.length, length2 = nums2.length; int index1 = 0, index2 = 0; int kthElement = 0; while (true) &amp;#123; // 边界情况 if (index1 == length1) &amp;#123; return nums2[index2 + k - 1]; &amp;#125; if (index2 == length2) &amp;#123; return nums1[index1 + k - 1]; &amp;#125; if (k == 1) &amp;#123; return Math.min(nums1[index1], nums2[index2]); &amp;#125; // 正常情况 int half = k / 2; int newIndex1 = Math.min(index1 + half, length1) - 1; int newIndex2 = Math.min(index2 + half, length2) - 1; int pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2]; if (pivot1 &lt;= pivot2) &amp;#123; k -= (newIndex1 - index1 + 1); index1 = newIndex1 + 1; &amp;#125; else &amp;#123; k -= (newIndex2 - index2 + 1); index2 = newIndex2 + 1; &amp;#125; &amp;#125; &amp;#125; &amp;#125; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://harbourzhang99.github.io/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"https://harbourzhang99.github.io/tags/leetcode/"},{"name":"二分查找","slug":"二分查找","permalink":"https://harbourzhang99.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"java 初始化相关问题 [类初始化和实例初始化]","slug":"java面试题[类初始化和实例初始化]","date":"2020-11-10T05:39:44.498Z","updated":"2020-11-11T09:51:18.595Z","comments":true,"path":"2020/11/10/java面试题[类初始化和实例初始化]/","link":"","permalink":"https://harbourzhang99.github.io/2020/11/10/java%E9%9D%A2%E8%AF%95%E9%A2%98[%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96]/","excerpt":"收获：对于java类初始化和实例初始化的思考。","text":"收获：对于java类初始化和实例初始化的思考。 public class Father&amp;#123; private int i = test(); private static int j = method(); static&amp;#123; System.out.print(\"(1)\"); &amp;#125; Father()&amp;#123; System.out.print(\"(2)\"); &amp;#125; &amp;#123; System.out.print(\"(3)\"); &amp;#125; public int test()&amp;#123; System.out.print(\"(4)\"); return 1; &amp;#125; public static int method()&amp;#123; System.out.print(\"(5)\"); return 1; &amp;#125; &amp;#125; public class Son extends Father&amp;#123; private int i = test(); private static int j = method(); static&amp;#123; System.out.print(\"(6)\"); &amp;#125; Son()&amp;#123; System.out.print(\"(7)\"); &amp;#125; &amp;#123; System.out.print(\"(8)\"); &amp;#125; public int test()&amp;#123; System.out.print(\"(9)\"); return 1; &amp;#125; public static int method()&amp;#123; System.out.print(\"(10)\"); return 1; &amp;#125; public static void main(String[] args) &amp;#123; Son s1 = new Son(); System.out.println(); Son s2 = new Son(); &amp;#125; &amp;#125; 运行结果： 类初始化和实例初始化java程序初始化时，最先进行的是类初始化，然后再进行实例初始化。这也比较容易理解，先有类才有对象。 其次是先进行静态代码的初始化，再非静态代码的初始化，最后进行构造器代码的执行。 1. 类初始化（1）一个类要创建实例需要先加载并初始化该类。其中，main方法所在的类需要先加载和初始化。 （2）一个子类要初始化需要先初始化父类 （3）java的类初始化，其实是执行了一个（）方法。==== （）方法由==静态类变量显式赋值代码==和==静态代码块==组成； 静态类变量显示赋值代码和静态代码块代码从上到下顺序执行。即==静态的代码按顺序执行==； （）方法只执行一次。 2. 实例初始化过程实例初始化其实是执行了（）方法。 （）方法可能重载有多个，有几个构造器就有几个（）方法； （）由非静态实例变量显式赋值代码和非静态代码块、对应构造器代码组成； 非静态实例变量显式赋值代码和非静态代码块，==这些非静态代码，按照顺序由上到下执行==，而对应的==构造器代码最后执行==； 每次创建实例对象，调用对应构造器，执行的就是对应的（）方法； ==（）方法的首行是super()或super(实参列表)==，即对应父类的方法。不论写不写super（），它都是存在的。 3. 方法的重写Override（1）哪些方法不能被重写 final 方法 静态方法 private等子类中不可见的方法 （2）对象的多态性 子类如果重写了父类的方法，通过子类对象调用的一定是子类重写过的代码。 非静态方法默认的调用对象是 this this 对象在构造器或者说（）方法中，就是正在创建的对象 4. 进阶（1）Override 和 Overload 的区别？ （2）Override 重写的要求？ （3）了解《JVM虚拟机规范》中关于和方法的说明、invokespecial指令 5. 例题解析 main方法所在类是Son，所以先加载Son所在类； 由于子类初始化之前需要先初始化父类，所以先加载 Father， 而 Father 没有父类了，所以直接加载Father； 类加载过程，即执行（）方法，执行静态的代码，并且这些静态的代码是按照从上到下执行的。因此，执行了（5）然后是（1）； 父类加载完成后，开始加载子类。同样地，按顺序执行了（10）（6）； 类加载完毕后，开始执行实例加载过程。同样地，实例化子类之前要先实例化父类。 实例化对象的过程，实质上是执行了（）方法，于是按顺序执行非静态的代码。这里先执行的是 private int i = test(); 实际上，==非静态方法默认的调用对象是 this==， 因此这句代码等同于: private int i = this.test(); 而 this 对象在构造器，或者说（）方法中，就是正在创建的对象，也就是正在创建的Son对象，也就是调用了子类重写的test（）方法。所以输出的应该是（9）。 执行完了test（）方法，接着就是执行非静态代码块，输出了（3），最后执行构造方法里的代码，输出了（2）。 按同样的规则，输出了（9）（8）（7）。","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://harbourzhang99.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"javase","slug":"javase","permalink":"https://harbourzhang99.github.io/tags/javase/"}]},{"title":"singleton单例模式","slug":"Singleton 单例模式","date":"2020-11-10T01:02:07.653Z","updated":"2020-11-10T06:16:47.388Z","comments":true,"path":"2020/11/10/Singleton 单例模式/","link":"","permalink":"https://harbourzhang99.github.io/2020/11/10/Singleton%20%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"一些关于单例模式的学习笔记","text":"一些关于单例模式的学习笔记 一、什么是Singleton？1. 简介Singleton： 在 java 中即指单例设计模式，它是软件开发中最常用的设计模式之一。 单例模式，==单：唯一； 例：实例== 单例设计模式，即某个类在整个系统中只能有一个实例对象可被获取和使用的代码模式。 例如：java的代表 JVM 运行环境的Runtime类。 2. 要点（1） 某个类只能有一个实例： 意味着构造器必须私有化 （2）它必须自行创建这个实例： 用含有一个该类的静态变量来保存这个唯一的实例 （3）它必须自行向整个系统提供这个实例： ​ 对外提供获取该实例对象的方式： ​ ==直接暴露；== ​ ==用静态变量的get方法获取。== 3. 饿汉式构造==在类初始化时直接创建对象，不存在线程安全问题== （1）直接实例化饿汉式（简洁直观） /** * @author Harbour * @create 2020-11-10 9:35 * * (1)构造器私有化 * (2)用静态变量存储此实例 * (3)向外提供这个实例，用public修饰 * (4)强调这是一个单例，可以用final修改，大写 */ public class Singleton01 &amp;#123; // 1. 直接实例化的方式 public static final Singleton01 INSTANCE = new Singleton01(); private Singleton01() &amp;#123;&amp;#125;; &amp;#125; （2）枚举式（最简洁） /** * @author Harbour * @create 2020-11-10 9:42 * (1) 枚举类: 表示该类型的对象只有有限的几个 * (2) 我们可以给他限定为1个，即成了单例模式 * (3) 枚举类的构造器都是私有化的 */ public enum Singleton02 &amp;#123; // 2. 直接枚举类创建 INSTANCE &amp;#125; （3）静态代码块饿汉式（适合复杂实例化） package singleton; import javax.annotation.Resource; import java.io.IOException; import java.util.Properties; /** * @author Harbour * @create 2020-11-10 9:46 * (1) 适用于复杂类型的单例，比如需要从外接加载必要的信息 */ public class Singleton03 &amp;#123; // 3. 静态代码块式的构造 public static final Singleton03 INSTANCE; private String info; static &amp;#123; try &amp;#123; Properties pro = new Properties(); pro.load(Singleton03.class.getClassLoader().getResourceAsStream(\"single.properties\")); INSTANCE = new Singleton03(pro.getProperty(\"info\")); &amp;#125; catch (IOException e) &amp;#123; throw new RuntimeException(e); &amp;#125; &amp;#125; private Singleton03(String info) &amp;#123; this.info = info; &amp;#125;; &amp;#125; 4. 懒汉式构造延迟创建对象，存在线程安全问题 （1）线程不安全（适用于单线程） package singleton; /** * @author Harbour * @create 2020-11-10 10:46 * 第一中懒汉式构造方式，存在线程安全问题,可能创建多个实例 */ public class Singleton04 &amp;#123; private static Singleton04 instance; private Singleton04 () &amp;#123;&amp;#125;; public Singleton04 getInstance() &amp;#123; if (instance != null) &amp;#123; try &amp;#123; /* 第一个线程等待了1000毫秒，然后继续创建实例 第二个线程在这1000毫秒之内进来了，然后也创建了实例 于是出现了两个实例，导致线程不安全 */ Thread.sleep(1000); &amp;#125; catch (InterruptedException e) &amp;#123; e.printStackTrace(); &amp;#125; instance = new Singleton04(); &amp;#125; return instance; &amp;#125; &amp;#125; （2）线程安全（适用于多线程） package singleton; /** * @author Harbour * @create 2020-11-10 10:46 * 第二种懒汉式构造方式，不存在线程安全问题 */ public class Singleton05 &amp;#123; private static Singleton05 instance; private Singleton05() &amp;#123;&amp;#125;; public Singleton05 getInstance() &amp;#123; // 外层判断是为了提高运行效率，没必要每次都执行内部同步代码块 if (instance != null) &amp;#123; // 内层同步代码块，保证第一次创建时不会存在线程安全问题 synchronized (Singleton05.class) &amp;#123; if (instance != null) &amp;#123; instance = new Singleton05(); &amp;#125; &amp;#125; &amp;#125; return instance; &amp;#125; &amp;#125; （3）静态内部类形式（适用于多线程） package singleton; /** * @author Harbour * @create 2020-11-10 10:46 * 第三种懒汉式构造方式，适用多线程 * (1)在内部类被加载和初始化时，才创建INSTANCE实例对象 * (2)静态内部类不会自动随着外部类的加载和初始化而初始化，它是要单独去加载和初始化的 * (3)因为是在内部类加载和初始化时，创建的，因此是线程安全的 */ public class Singleton06 &amp;#123; private Singleton06() &amp;#123;&amp;#125;; private static class Inner&amp;#123; private static final Singleton06 INSTANCE = new Singleton06(); &amp;#125; public static Singleton06 getInstance () &amp;#123; return Inner.INSTANCE; &amp;#125; &amp;#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://harbourzhang99.github.io/tags/java/"},{"name":"面试题","slug":"面试题","permalink":"https://harbourzhang99.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"Leetcode  0003","slug":"Leetcode0003","date":"2020-11-09T13:26:48.133Z","updated":"2020-11-09T13:37:38.373Z","comments":true,"path":"2020/11/09/Leetcode0003/","link":"","permalink":"https://harbourzhang99.github.io/2020/11/09/Leetcode0003/","excerpt":"收获：对于滑动窗口思考。","text":"收获：对于滑动窗口思考。 这道题一拿过来，倒是想到了用滑动窗口做。做的过程中出现了这么个问题： （1）如果最后一个字符没有重复，那么整体长度正常 （2）如果最后一个字符重复了，那么整体长度会增加1 是因为，最后一个字符如果重复了，那么最后一个字符的下标就用上了，而start位置的下标是那个重复字符的下标，于是这个重复字符就计算了两次。 然后瞄了一眼别人的答案，发现我的思路还是有很多的问题： （1）不论当前字符是否重复，当前字符都应当加入hashmap中。 （2）就算当前字符重复了，也不需要将之前存入hashmap的字符删除。因为把当前字符存入hashmap的时候，它会自动覆盖之前存储的键值对。 （3）当修改滑动窗口的左边位置时，应该想到，左边的窗口位置始终是一直变大的。而不是让左边的窗口位置回到上一个重复节点的位置。比如“abba”，第一次重复时，让左边窗口位置定位到b，而第二次重复时，如果把窗口左边位置定位回a，就会造成结果的错误。 我的答案：public static int lengthOfLongestSubstring(String s) &amp;#123; int start = 0; int end = 0; int len = 0; char[] chars = s.toCharArray(); HashMap&lt;Character, Integer> map = new HashMap&lt;>(); while ( end &lt; chars.length ) &amp;#123; if (map.containsKey(chars[end])) &amp;#123; start = Math.max(map.get(chars[end]) + 1,start); // start = map.get(chars[end]) + 1; &amp;#125; map.put(chars[end], end); len = Math.max(end - start + 1, len); end++; &amp;#125; return len; &amp;#125; 官方答案：class Solution &amp;#123; public int lengthOfLongestSubstring(String s) &amp;#123; // 哈希集合，记录每个字符是否出现过 Set&lt;Character> occ = new HashSet&lt;Character>(); int n = s.length(); // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动 int rk = -1, ans = 0; for (int i = 0; i &lt; n; ++i) &amp;#123; if (i != 0) &amp;#123; // 左指针向右移动一格，移除一个字符 occ.remove(s.charAt(i - 1)); &amp;#125; while (rk + 1 &lt; n &amp;&amp; !occ.contains(s.charAt(rk + 1))) &amp;#123; // 不断地移动右指针 occ.add(s.charAt(rk + 1)); ++rk; &amp;#125; // 第 i 到 rk 个字符是一个极长的无重复字符子串 ans = Math.max(ans, rk - i + 1); &amp;#125; return ans; &amp;#125; &amp;#125; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://harbourzhang99.github.io/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"https://harbourzhang99.github.io/tags/leetcode/"}]},{"title":"Leetcode  0001","slug":"Leetcode0001","date":"2020-11-09T02:44:44.537Z","updated":"2020-11-09T05:29:14.028Z","comments":true,"path":"2020/11/09/Leetcode0001/","link":"","permalink":"https://harbourzhang99.github.io/2020/11/09/Leetcode0001/","excerpt":"收获：对于去重，查找唯一的思考。","text":"收获：对于去重，查找唯一的思考。 由于当天没有准时写笔记，导致思路有些模糊。 （1）寻找匹配的两个数，如果用两层for循环，时间复杂度会非常高。而hashmap有个containsKey方法，很高效。并且hashmap还有去重的效果。 我的答案：class Solution &amp;#123; public int[] twoSum(int[] nums, int target) &amp;#123; HashMap&lt;Integer, Integer> hashmap = new HashMap&lt;>(); for(int i=0;i&lt;nums.length;i++)&amp;#123; if (hashmap.containsKey(target - nums[i]))&amp;#123; return new int []&amp;#123; hashmap.get(target - nums[i]),i&amp;#125;; &amp;#125;else&amp;#123; hashmap.put(nums[i],i); &amp;#125; &amp;#125; return new int[] &amp;#123;&amp;#125;; &amp;#125; &amp;#125; 官方答案：class Solution &amp;#123; public int[] twoSum(int[] nums, int target) &amp;#123; Map&lt;Integer, Integer> hashtable = new HashMap&lt;Integer, Integer>(); for (int i = 0; i &lt; nums.length; ++i) &amp;#123; if (hashtable.containsKey(target - nums[i])) &amp;#123; return new int[]&amp;#123;hashtable.get(target - nums[i]), i&amp;#125;; &amp;#125; hashtable.put(nums[i], i); &amp;#125; return new int[0]; &amp;#125; &amp;#125; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://harbourzhang99.github.io/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"https://harbourzhang99.github.io/tags/leetcode/"}]},{"title":"Leetcode  0002","slug":"Leetcode0002","date":"2020-11-09T02:16:38.131Z","updated":"2020-11-09T02:44:39.549Z","comments":true,"path":"2020/11/09/Leetcode0002/","link":"","permalink":"https://harbourzhang99.github.io/2020/11/09/Leetcode0002/","excerpt":"收获：对于链表的节点，游标的思考。","text":"收获：对于链表的节点，游标的思考。 （1）当需要构造一个链表的时候，可以用一个游标cursor指向根节点。 （2）取到一个新结点的值以后，将该值赋予cursor-&gt;next。如下代码，由于构造方法里有这样一个构造器，所以会自动构造一个节点，连接上cursor的next。 ListNode(int val) &amp;#123; this.val = val; &amp;#125; （3）将cursor指向其next。cursor原本引用的是root的地址值，现在让其指向next，就相当于让cursor引用root的next的地址值，也即步骤（2）中新结点的地址值。这样做，可以让我们的链表继续向后添加，并且也不会对原有链表的节点造成破坏。 （4）在步骤（2）里，是不能让cursor直接变成新结点的。否则步骤（3）中，cursor的next是空节点，而cursor又指向其next，这时等于清空了root值，导致链表一直进行“ cursor变为新结点-&gt; cursor指向next -&gt; cursor变为空 -&gt; cursor变为新结点…. ”的死循环。 我的答案：/** * Definition for singly-linked list. * public class ListNode &amp;#123; * int val; * ListNode next; * ListNode() &amp;#123;&amp;#125; * ListNode(int val) &amp;#123; this.val = val; &amp;#125; * ListNode(int val, ListNode next) &amp;#123; this.val = val; this.next = next; &amp;#125; * &amp;#125; */ class Solution &amp;#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &amp;#123; ListNode root = new ListNode(0); ListNode cursor = root; int more = 0; int val = 0; while ( l1 != null || l2 != null || more != 0) &amp;#123; if (l1 == null &amp;&amp; l2 == null) &amp;#123; val = more; more = 0; &amp;#125;else if (l1 == null) &amp;#123; // val是当前位应该存放的数字，more是进一位的值 val = (l2.val + more) % 10; more = (l2.val + more) / 10; &amp;#125;else if (l2 == null) &amp;#123; // val是当前位应该存放的数字，more是进一位的值 val = (l1.val + more) % 10; more = (l1.val + more) / 10; &amp;#125;else&amp;#123; // val是当前位应该存放的数字，more是进一位的值 val = (l1.val + l2.val + more) % 10; more = (l1.val + l2.val + more) / 10; &amp;#125; cursor.next = new ListNode(val); cursor = cursor.next; if (l1 != null) &amp;#123; l1 = l1.next; &amp;#125; if (l2 != null) &amp;#123; l2 = l2.next; &amp;#125; &amp;#125; return root.next; &amp;#125; &amp;#125; 官方答案：class Solution &amp;#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &amp;#123; ListNode head = null, tail = null; int carry = 0; while (l1 != null || l2 != null) &amp;#123; int n1 = l1 != null ? l1.val : 0; int n2 = l2 != null ? l2.val : 0; int sum = n1 + n2 + carry; if (head == null) &amp;#123; head = tail = new ListNode(sum % 10); &amp;#125; else &amp;#123; tail.next = new ListNode(sum % 10); tail = tail.next; &amp;#125; carry = sum / 10; if (l1 != null) &amp;#123; l1 = l1.next; &amp;#125; if (l2 != null) &amp;#123; l2 = l2.next; &amp;#125; &amp;#125; if (carry > 0) &amp;#123; tail.next = new ListNode(carry); &amp;#125; return head; &amp;#125; &amp;#125; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/add-two-numbers/solution/liang-shu-xiang-jia-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://harbourzhang99.github.io/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"https://harbourzhang99.github.io/tags/leetcode/"}]},{"title":"spring cloud 云服务分布式架构","slug":"GuliMall","date":"2020-11-07T12:01:51.000Z","updated":"2020-11-09T02:41:51.622Z","comments":true,"path":"2020/11/07/GuliMall/","link":"","permalink":"https://harbourzhang99.github.io/2020/11/07/GuliMall/","excerpt":"一些关于微服务，分布式架构的学习笔记","text":"一些关于微服务，分布式架构的学习笔记 一、Spring Could Nacos 【注册中心】1. 下载地址：https://github.com/alibaba/nacos/releases 2. 启动（1） bin目录下 点击startup.cmd（2）配置依赖&lt;dependency> &lt;groupId>com.alibaba.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId> &lt;version>2.2.1.RELEASE&lt;/version> &lt;/dependency> （3）配置application.yml文件spring: application: name: gulimall-member cloud: nacos: discovery: server-addr: 127.0.0.1:8848 （4）在主启动类上添加 @EnableDiscoveryClient 注解（5）启动主启动类。二、SpringCloud Feign微服务之间互相调用的一个声明式的Web Service客户端。当本服务想要调用外部服务时，使用feign来建立一个接口，本服务调用此接口，此接口再调用外部服务返回信息。 1. 使用步骤：（1）配置依赖&lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-openfeign&lt;/artifactId> &lt;/dependency> （2）告诉springcloud 使用Feign进行微服务之间的调用​ 创建 Feign 包，对应的微服务Service接口， 并添加@ FeignClient注解。 注意方法名最好一致 // 待调用服务的Controller @RequestMapping(\"coupon/coupon\") public class CouponController &amp;#123; @Autowired private CouponService couponService; @RequestMapping(\"/test\") public R couponToMember() &amp;#123; CouponEntity entity = new CouponEntity(); entity.setCouponName(\"测试使用-满100减50\"); return R.ok().put(\"coupon\",entity); &amp;#125; &amp;#125; // Feign接口 @FeignClient(\"gulimall-coupon\") // 如果要调用接口的这个方法，先从注册中心的这个微服务开始寻找 public interface CouponFeignService &amp;#123; @RequestMapping(\"/coupon/coupon/test\") public R couponToMember(); &amp;#125; // 本服务的Controller @Resource private CouponFeignService service; @RequestMapping(\"/test\") public R couponToMember() &amp;#123; R r = service.couponToMember(); return r; &amp;#125; （3）在主启动类上添加 @EnableFeignClient 注解@EnableFeignClients(basePackages = \"com.atguigu.gulimall.member.feign\") 三、Nacos 作为配置中心1. 使用步骤：（1） 配置依赖：&lt;dependency> &lt;groupId>com.alibaba.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-alibaba-nacos-config&lt;/artifactId> &lt;/dependency> （2） 创建配置文件 bootstrap.properties, 并添加以下配置spring.cloud.nacos.config.server-addr=127.0.0.1:8848 spring.application.name=gulimall-member （3） 在Nacos服务中心创建【服务名.properties】配置文件member.username=harbour member.info=测试文件 （4）编写相关业务逻辑（5）在对应的Controller上添加@RefreshScope的注解@RefreshScope 2. 环境隔离每个微服务创建自己的命名空间，使用配置分组区分环境，如dev，test，prod等 （1） 命名空间：默认public，用于在微服务之间进行配置隔离，每个微服务创建自己的命名空间，需要在bootstrap.properties加入以下配置： spring.cloud.nacos.config.namespace= 【Nacos中的命名空间ID】 （2） 配置集：所有配置的集合 （3） 配置集ID:Data-ID : 类似于配置文件名 （4）配置分组：需要在bootstrap.properties加入以下配置： spring.cloud.nacos.config.group= 【Nacos中的分组名】 3. 加载多配置文件在bootstrap.properties中，使用spring.cloud.nacos.config.ext-config配置配置文件。默认加载【文件名-properties】配置文件。 spring.cloud.nacos.config.ext-config[0].data-id=mybatis.yaml spring.cloud.nacos.config.ext-config[0].group=dev spring.cloud.nacos.config.ext-config[0].refresh=true spring.cloud.nacos.config.ext-config[1].data-id=datasource.yaml spring.cloud.nacos.config.ext-config[1].group=dev spring.cloud.nacos.config.ext-config[1].refresh=true spring.cloud.nacos.config.ext-config[2].data-id=cloud.yaml spring.cloud.nacos.config.ext-config[2].group=dev spring.cloud.nacos.config.ext-config[2].refresh=true 四、Spring Cloud Gateway1.使用步骤（1）导入依赖：&lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-gateway&lt;/artifactId> &lt;/dependency> （2）根据不同的需求，配置yamlspring: cloud: gateway: routes: - id: admin_route uri: lb://renren-fast predicates: - Path=/api/** filters: - RewritePath=/api/(?&lt;segment>.*),/renren-fast/$\\&amp;#123;segment&amp;#125; nacos: discovery: server-addr: 127.0.0.1:8848 application: name: gulimall-gateway server: port: 88 (3) 修改主启动类在主启动类上增加@EnableDiscoveyClient 注解 五、解决浏览器跨域解决方案：@Configuration public class MyCorsConfiguration &amp;#123; public CorsWebFilter getCorsWebFilter () &amp;#123; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); CorsConfiguration configuration = new CorsConfiguration(); configuration.addAllowedHeader(\"*\"); configuration.addAllowedMethod(\"*\"); configuration.addAllowedOrigin(\"*\"); configuration.setAllowCredentials(true); source.registerCorsConfiguration(\"/**\",configuration); return new CorsWebFilter(source); &amp;#125; &amp;#125; 六、整合MybatisPlus1.导入依赖&lt;dependency> &lt;groupId>com.baomidou&lt;/groupId> &lt;artifactId>mybatis-plus-boot-starter&lt;/artifactId> &lt;version>3.3.1&lt;/version> &lt;/dependency> &lt;!-- 数据源 --> &lt;dependency> &lt;groupId>com.alibaba&lt;/groupId> &lt;artifactId>druid&lt;/artifactId> &lt;version>1.1.13&lt;/version> &lt;/dependency> 2. 配置（1）配置数据源# 配置mybatisplus mybatis-plus: # MyBatis Mapper 所对应的 XML 文件位置 # Maven 多模块项目的扫描路径需以 classpath*: 开头 （即加载多个 jar 包下的 XML 文件） mapper-locations: classpath*:/mapper/**/*.xml # 设置主键自增 global-config: db-config: id-type: auto （2）使用@MapperScan注解使用@MapperScan注解告诉MybatisPlus的sql映射位置 3.逻辑删除（1）配置yaml (注：since 3.3.0,配置后可以忽略不配置步骤2)mybatis-plus: global-config: db-config: logic-delete-field: flag # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2) logic-delete-value: 1 # 逻辑已删除值(默认为 1) logic-not-delete-value: 0 # 逻辑未删除值(默认为 0) （2）实体类字段上加上@TableLogic注解@TableLogic private Integer deleted;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://harbourzhang99.github.io/tags/java/"},{"name":"spring cloud","slug":"spring-cloud","permalink":"https://harbourzhang99.github.io/tags/spring-cloud/"}]}],"categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://harbourzhang99.github.io/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"https://harbourzhang99.github.io/tags/leetcode/"},{"name":"回文","slug":"回文","permalink":"https://harbourzhang99.github.io/tags/%E5%9B%9E%E6%96%87/"},{"name":"动态规划","slug":"动态规划","permalink":"https://harbourzhang99.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"ssm","slug":"ssm","permalink":"https://harbourzhang99.github.io/tags/ssm/"},{"name":"数据库","slug":"数据库","permalink":"https://harbourzhang99.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"事务","slug":"事务","permalink":"https://harbourzhang99.github.io/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"面试题","slug":"面试题","permalink":"https://harbourzhang99.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"javase","slug":"javase","permalink":"https://harbourzhang99.github.io/tags/javase/"},{"name":"二分查找","slug":"二分查找","permalink":"https://harbourzhang99.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"java","slug":"java","permalink":"https://harbourzhang99.github.io/tags/java/"},{"name":"spring cloud","slug":"spring-cloud","permalink":"https://harbourzhang99.github.io/tags/spring-cloud/"}]}